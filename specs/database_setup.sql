--
-- SQL Script Completo para Configuração do Banco de Dados Namorim no Supabase
--
-- Este script cria todas as tabelas, políticas de RLS, triggers e configurações de storage
-- necessárias para o aplicativo Namorim. Ele foi projetado para ser idempotente,
-- permitindo execuções múltiplas sem erros.
--

-- ===============================================
-- 1. Tabela 'profiles' e Storage 'avatars'
--    (Baseado em specs/database-schema.sql)
-- ===============================================

-- Cria a tabela 'profiles' se não existir
CREATE TABLE IF NOT EXISTS profiles (
  id UUID PRIMARY KEY REFERENCES auth.users(id) ON DELETE CASCADE,
  username TEXT UNIQUE,
  avatar_url TEXT,
  bio TEXT,
  updated_at TIMESTAMPTZ DEFAULT NOW(),
  created_at TIMESTAMPTZ DEFAULT NOW(),

  CONSTRAINT username_length CHECK (char_length(username) >= 3)
);

-- Ativa o Row Level Security (RLS) para 'profiles'
ALTER TABLE profiles ENABLE ROW LEVEL SECURITY;

-- Políticas de RLS para 'profiles'
DROP POLICY IF EXISTS "Public profiles are viewable by everyone." ON profiles;
CREATE POLICY "Public profiles are viewable by everyone."
  ON profiles FOR SELECT
  USING ( true );

DROP POLICY IF EXISTS "Users can insert their own profile." ON profiles;
CREATE POLICY "Users can insert their own profile."
  ON profiles FOR INSERT
  WITH CHECK ( auth.uid() = id );

DROP POLICY IF EXISTS "Users can update own profile." ON profiles;
CREATE POLICY "Users can update own profile."
  ON profiles FOR UPDATE
  USING ( auth.uid() = id );

-- Função para atualizar automaticamente a coluna 'updated_at'
CREATE OR REPLACE FUNCTION handle_updated_at()
RETURNS TRIGGER AS $$
BEGIN
  NEW.updated_at = NOW();
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- Trigger para a função 'handle_updated_at' na tabela 'profiles'
DROP TRIGGER IF EXISTS on_profile_updated ON profiles;
CREATE TRIGGER on_profile_updated
  BEFORE UPDATE ON profiles
  FOR EACH ROW
  EXECUTE PROCEDURE handle_updated_at();

-- Configura o bucket de Storage para imagens de perfil (avatars)
INSERT INTO storage.buckets (id, name, public)
VALUES ('avatars', 'avatars', true)
ON CONFLICT (id) DO NOTHING;

-- Políticas de RLS para o Storage de 'avatars'
DROP POLICY IF EXISTS "Avatar images are publicly accessible." ON storage.objects;
CREATE POLICY "Avatar images are publicly accessible."
  ON storage.objects FOR SELECT
  USING ( bucket_id = 'avatars' );

DROP POLICY IF EXISTS "Anyone can upload an avatar." ON storage.objects;
CREATE POLICY "Anyone can upload an avatar."
  ON storage.objects FOR INSERT
  WITH CHECK ( bucket_id = 'avatars' );

DROP POLICY IF EXISTS "Users can update their own avatar." ON storage.objects;
CREATE POLICY "Users can update their own avatar."
    ON storage.objects FOR UPDATE
    USING ( auth.uid() = owner )
    WITH CHECK ( bucket_id = 'avatars' );


-- ===============================================
-- 2. Tabelas 'likes' e 'dislikes'
-- ===============================================

-- Tabela 'likes'
CREATE TABLE IF NOT EXISTS likes (
  user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
  liked_user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
  created_at TIMESTAMPTZ DEFAULT NOW(),
  PRIMARY KEY (user_id, liked_user_id)
);

-- Ativa o RLS para 'likes'
ALTER TABLE likes ENABLE ROW LEVEL SECURITY;

-- Políticas de RLS para 'likes'
DROP POLICY IF EXISTS "Users can insert their own likes." ON likes;
CREATE POLICY "Users can insert their own likes."
  ON likes FOR INSERT
  WITH CHECK ( auth.uid() = user_id );

DROP POLICY IF EXISTS "Users can view their own likes." ON likes;
CREATE POLICY "Users can view their own likes."
  ON likes FOR SELECT
  USING ( auth.uid() = user_id );


-- Tabela 'dislikes'
CREATE TABLE IF NOT EXISTS dislikes (
  user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
  disliked_user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
  created_at TIMESTAMPTZ DEFAULT NOW(),
  PRIMARY KEY (user_id, disliked_user_id)
);

-- Ativa o RLS para 'dislikes'
ALTER TABLE dislikes ENABLE ROW LEVEL SECURITY;

-- Políticas de RLS para 'dislikes'
DROP POLICY IF EXISTS "Users can insert their own dislikes." ON dislikes;
CREATE POLICY "Users can insert their own dislikes."
  ON dislikes FOR INSERT
  WITH CHECK ( auth.uid() = user_id );


-- ===============================================
-- 3. Tabela 'messages' (para chat)
-- ===============================================

-- Tabela 'messages'
CREATE TABLE IF NOT EXISTS messages (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  sender_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
  receiver_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
  content TEXT NOT NULL,
  created_at TIMESTAMPTZ DEFAULT NOW()
);

-- Ativa o RLS para 'messages'
ALTER TABLE messages ENABLE ROW LEVEL SECURITY;

-- Políticas de RLS para 'messages'
DROP POLICY IF EXISTS "Users can view their own messages." ON messages;
CREATE POLICY "Users can view their own messages."
  ON messages FOR SELECT
  USING ( auth.uid() = sender_id OR auth.uid() = receiver_id );

DROP POLICY IF EXISTS "Users can insert their own messages." ON messages;
CREATE POLICY "Users can insert their own messages."
  ON messages FOR INSERT
  WITH CHECK ( auth.uid() = sender_id );

-- ===============================================
-- 4. Configuração de Realtime para o Supabase
-- ===============================================

-- Adiciona a tabela 'messages' para ser publicada em tempo real
ALTER PUBLICATION supabase_realtime ADD TABLE messages;
